# データハンドリング
## 種族値分析編
### tidyverseの世界
データ分析では，各変数の分布の特徴を捉え，
変数間の関連を検討し，情報を得ようとします。
また，変数の変換や新たな変数の追加などを頻繁に行います。

ここでは，<code>pokemon.xlsx</code>を分析しながら，
パッケージ<code>tidyverse</code>を利用して
効率的に分析を進める方法を確認しましょう。

基本となる関数は以下の3つです。
1. <code>select()</code>：特定の変数を選択する
1. <code>mutate()</code>：変数を変換したり，新しい変数を追加したりする
1. <code>summarize()</code>：平均や標準偏差など，変数の要約結果を得る

### 変数の取り出し
tidyなtable状のデータフレームであるtibble形式のデータから変数を取り出すには，関数<code>select()</code>を使います。
抜き出したい変数の名前に引用符<code>" "</code>を付ける必要はありません。
取り出した結果もtibble形式であり，
指定した順に抜き出されるので，変数の並べ替えにも使えます。

```{r}
require(tidyverse)
require(readxl) # tidyverseと一緒にインストールされるが起動はされない
flnm <- "~/Downloads/pokemon.xlsx"
tbl_p <- read_xlsx(flnm)
colnames(tbl_p)
```

```{r, eval=FALSE}
tbl_p |>
  select(ポケモン, 速さ, HP)
# 出力略
```

ここで<code>|></code>は<code>%>%</code>と同じ**パイプ演算子**です。baseの（追加のパッケージが不要な）**R**で使用できます。

変数を1つだけ，シンプルなベクトルとして取り出すには，
関数<code>pull()</code>を用います。
tibble形式のデータを受け取っても処理できない関数などに対して利用します。指定する変数は1つです。

### 効率的な取り出し方法
変数名を指定するのではなく，列の番号でも指定可能です。
また，<code>select()</code>には変数の選択に便利な「お助け(helper)」関数，補助関数が用意されており，
効率的に変数を取り出せます。
詳細は
<code>help(select)</code>として[Useful functions]の項を
参照してください。

1. <code>starts_with()</code>：指定した文字列から始まる変数を取り出す
1. <code>ends\_with()</code>：指定した文字列で終わる変数を取り出す
1. <code>matches()</code>： 指定の文字列（正規表現と呼ばれる特殊な指定も可）に合致する変数を取り出す
1. 記号<code> : </code>：あたかも数値列のように変数の
    並びを表せる（<code>select(HP:速さ)</code>で6変数を選択可）
1. 記号<code> - </code>マイナスを変数名の前に付けると除外できる

### データの変換
918体のポケモンについて，それぞれの総合ステータスを求めましょう。
つまり，「HP」から「速さ」の値をポケモンごとに単純合計します。
データの変換には関数<code>mutate()</code>を使います。
```{r}
tbl_p2 <- tbl_p %>% 
 mutate(total=HP+攻撃+防御+特攻+特防+速さ)
```

記号<code><-</code>\texttt{<-}は右側を左側に格納する指示でしたが，
記号<code>%>%</code>は右側**へ**左側**を渡す**
指示です。
つまり，
データのオブジェクト<code>tbl_p</code>
を関数<code>mutate()</code>
に渡し，その結果をオブジェクト<code>tbl_p2</code>
に格納しています。

2行目の<code>mutate()</code>では，
新しい変数<code>total</code>を作成，定義
していますが，
これは引数ではなく変数名なので，例えば「総合」にしたり
「種族値合計」にしたり好きに設定できます。

変数<code>total</code>はHPから速さを足したものです。
パイプ演算子<code>%>%</code>によってデータが
<code>mutate()</code>
に渡されているので，引用符なしで計算式を直接記述しています。

### 偏差値での検討
数学と英語の成績を比較する際に偏差値がよく使われるのは，
数学と英語の平均点が同じとは限らず，数学の80点と英語の
80点を同じ「80」として比較できないからです。
また，散らばりの大きさも異なる可能性があるので，
1点の差が数学と英語で同じ保証もありません。
数学の最低点が79点，最高点が81点，
英語では最低点が5点，最高点95点のときの1点の違いを想像してみてください。

ポケモンデータでも同じことがいえます。
「HP」と「攻撃」をそのままの値で比較するのは，数学と
英語の成績を直接比べるようなものです。そこで，
**標準得点**（standard score）
の考え方でデータを見直してみましょう。

標準得点は，データを特定の平均と
散らばり（分散，または標準偏差の値）に変換し，
目盛(scale)を統一する**標準化**(standardization)の結果
として得られる値です。
データ分析においてよく使われるのは，平均を0，標準偏差を1とした
標準得点です。
平均を引いて，標準偏差で割ることで，数学も英語も「HP」も
「攻撃」もすべて平均0，標準偏差1に目盛が揃ったデータになります。


偏差値も標準得点の1つです。
平均0，標準偏差1の標準得点を10倍し，50を足すと偏差値になります。
小数点以下の細かい表示を10倍して回避し，50を足して
マイナスの値を解消しています。もともと平均が0，標準偏差が1だったので，
偏差値の平均は50，標準偏差は10です。

では，偏差値を計算する関数を作ってみましょう。

```{r}
calculate_Hscore <- function(x){
  z <- (x - mean(x)) / sd(x)
  h <- z * 10 + 50
  return(h)
}
```

自作の関数<code>calculate_Hscore()</code>では，
引数<code>x</code>にデータを指定します。
<code>x</code>は2行目で平均が引かれ，標準偏差で割られるので，
平均0，標準偏差1に標準化されます。
それを10倍して50を足した結果を<code>h</code>として格納し，
関数<code>return()</code>で結果を返すようにしています。

この関数を利用して，関数<code>mutate()</code>によるデータの変換を
以下のように行えば，数量データについて一括して
偏差値を計算可能です。
変数の指定にあたっては，関数<code>across()</code>では
<code>select()</code>と同じように，tidy-selectと呼ばれる
変数選択のための補助関数など便利な機能が使用できます。

```{r}
tbl_p3 <- tbl_p2 |>
  mutate(across(HP:速さ, ~{
    calculate_Hscore(.)
  }))
# tbl_p3
```

上記の書き方では，
元の変数の内容が変更されますが，
オリジナルの変数の値を保持しておきたい場合は
<code>across()</code>の引数<code>.names</code>
を利用して，例えば以下のように記述します。

```{r, eval=FALSE}
tbl_p2 |>
  mutate(across(HP:速さ, ~{
    calculate_Hscore(.)
  }, .names = "{.col}_h"))
# 出力略
```

これにより，元の変数名それぞれに自動的に<code>_h</code>が付されます。
もちろん，<code>_h</code>の部分は好きな文字列で構いません。

<code>"{.col}_h"</code>の<code>{.col}</code>は，
文字列表示に関わる<code>glue</code>というパッケージが
提供する記法で，変数名を表します。

<code>across()</code>によって各変数に適用したい処理は，
通常の関数の使用と同様にカッコを付し，ドットを指定します。
ただし，関数の前に<code> ~ </code>が必要です。 

各偏差値を合計した結果と「HP」などの値をそのまま合計した総合ステータスには
どのような違いがあるか，モンスター分析編で検討する準備として，
ここでは偏差値の合計を計算し，新たな変数<code>h_total</code>
を作成しておきましょう。

```{r}
tbl_h <- tbl_p2 |>
  mutate(h_total=HP+攻撃+防御+特攻+特防+速さ)
tbl_h |> select(ポケモン, total, h_total)
```

